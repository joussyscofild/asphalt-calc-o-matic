import { useState, useEffect } from 'react';
import { Page } from '@/components/admin/pages/types';
import { supabase } from "@/integrations/supabase/client";
import { toast } from "@/hooks/use-toast";
import { UsePageManagerReturn } from './types';

export const usePageManager = (): UsePageManagerReturn => {
  const [pages, setPages] = useState<Page[]>([]);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [currentPage, setCurrentPage] = useState<Page | null>(null);
  const [pageContent, setPageContent] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    const fetchPages = async () => {
      setIsLoading(true);
      try {
        const { data, error } = await supabase
          .from('custom_pages')
          .select('*')
          .order('sort_order', { ascending: true })
          .order('created_at', { ascending: false });
        
        if (error) {
          throw error;
        }
        
        if (data) {
          const formattedPages: Page[] = data.map(page => ({
            id: page.id,
            title: page.title,
            slug: page.slug,
            status: page.status as 'published' | 'draft',
            content: page.content,
            created: new Date(page.created_at).toISOString().split('T')[0],
            lastModified: new Date(page.last_modified).toISOString().split('T')[0],
          }));
          
          setPages(formattedPages);
        }
      } catch (error) {
        console.error('Error fetching pages:', error);
        toast({
          title: "Error fetching pages",
          description: "There was a problem loading pages. Please try again.",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchPages();
  }, []);
  
  const handleCreatePage = () => {
    const newPage: Page = {
      id: '', // Will be generated by Supabase
      title: 'New Page',
      slug: 'new-page-' + Date.now().toString().slice(-4),
      status: 'draft',
      content: '<h1>New Page</h1><p>Add your content here.</p>',
      created: new Date().toISOString().split('T')[0],
      lastModified: new Date().toISOString().split('T')[0],
    };
    
    setCurrentPage(newPage);
    setPageContent(newPage.content);
    setIsEditDialogOpen(true);
  };
  
  const handleEditPage = (page: Page) => {
    setCurrentPage(page);
    setPageContent(page.content);
    setIsEditDialogOpen(true);
  };
  
  const handleSavePage = async () => {
    if (!currentPage) return;
    
    const now = new Date().toISOString();
    const today = now.split('T')[0];
    
    try {
      if (currentPage.id) {
        const { error } = await supabase
          .from('custom_pages')
          .update({
            title: currentPage.title,
            slug: currentPage.slug,
            content: pageContent,
            status: currentPage.status,
            last_modified: now,
          })
          .eq('id', currentPage.id);
        
        if (error) throw error;
        
        setPages(pages.map(p => 
          p.id === currentPage.id 
            ? {...currentPage, content: pageContent, lastModified: today} 
            : p
        ));
        
        toast({
          title: "Page updated",
          description: `"${currentPage.title}" has been updated successfully.`,
        });
      } else {
        const { data, error } = await supabase
          .from('custom_pages')
          .insert({
            title: currentPage.title,
            slug: currentPage.slug,
            content: pageContent,
            status: currentPage.status,
          })
          .select();
        
        if (error) throw error;
        
        if (data && data[0]) {
          const newPage: Page = {
            id: data[0].id,
            title: data[0].title,
            slug: data[0].slug,
            status: data[0].status as 'published' | 'draft',
            content: data[0].content,
            created: new Date(data[0].created_at).toISOString().split('T')[0],
            lastModified: new Date(data[0].last_modified).toISOString().split('T')[0],
          };
          
          setPages([newPage, ...pages]);
          
          toast({
            title: "Page created",
            description: `"${newPage.title}" has been created successfully.`,
          });
        }
      }
      
      setIsEditDialogOpen(false);
    } catch (error) {
      console.error('Error saving page:', error);
      toast({
        title: "Error saving page",
        description: "There was a problem saving the page. Please try again.",
        variant: "destructive",
      });
    }
  };
  
  const handleDeletePage = async (id: string) => {
    try {
      const { error } = await supabase
        .from('custom_pages')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
      
      setPages(pages.filter(p => p.id !== id));
      
      toast({
        title: "Page deleted",
        description: "The page has been deleted successfully.",
      });
    } catch (error) {
      console.error('Error deleting page:', error);
      toast({
        title: "Error deleting page",
        description: "There was a problem deleting the page. Please try again.",
        variant: "destructive",
      });
    }
  };
  
  const handleDuplicatePage = async (page: Page) => {
    try {
      const duplicateTitle = `${page.title} (Copy)`;
      const duplicateSlug = `${page.slug}-copy-${Date.now().toString().slice(-4)}`;
      
      const { data, error } = await supabase
        .from('custom_pages')
        .insert({
          title: duplicateTitle,
          slug: duplicateSlug,
          content: page.content,
          status: 'draft',
        })
        .select();
      
      if (error) throw error;
      
      if (data && data[0]) {
        const newPage: Page = {
          id: data[0].id,
          title: data[0].title,
          slug: data[0].slug,
          status: data[0].status as 'published' | 'draft',
          content: data[0].content,
          created: new Date(data[0].created_at).toISOString().split('T')[0],
          lastModified: new Date(data[0].last_modified).toISOString().split('T')[0],
        };
        
        setPages([newPage, ...pages]);
        
        toast({
          title: "Page duplicated",
          description: `"${duplicateTitle}" has been created.`,
        });
      }
    } catch (error) {
      console.error('Error duplicating page:', error);
      toast({
        title: "Error duplicating page",
        description: "There was a problem duplicating the page. Please try again.",
        variant: "destructive",
      });
    }
  };
  
  const handleStatusToggle = async (id: string) => {
    try {
      const page = pages.find(p => p.id === id);
      if (!page) return;
      
      const newStatus = page.status === 'published' ? 'draft' : 'published';
      
      const { error } = await supabase
        .from('custom_pages')
        .update({
          status: newStatus,
          last_modified: new Date().toISOString()
        })
        .eq('id', id);
      
      if (error) throw error;
      
      setPages(pages.map(page => {
        if (page.id === id) {
          return {
            ...page,
            status: newStatus,
            lastModified: new Date().toISOString().split('T')[0]
          };
        }
        return page;
      }));
      
      toast({
        title: `Page ${newStatus === 'published' ? 'published' : 'unpublished'}`,
        description: `The page has been ${newStatus === 'published' ? 'published' : 'set to draft'}.`
      });
    } catch (error) {
      console.error('Error toggling page status:', error);
      toast({
        title: "Error updating page status",
        description: "There was a problem updating the page status. Please try again.",
        variant: "destructive",
      });
    }
  };

  const handlePreviewPage = (page: Page) => {
    window.open(`/page/${page.slug}`, '_blank');
  };
  
  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!currentPage) return;
    
    const title = e.target.value;
    let slug = title.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
    
    setCurrentPage({
      ...currentPage,
      title,
      slug
    });
  };
  
  const handleSlugChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!currentPage) return;
    
    const slug = e.target.value.toLowerCase().replace(/[^\w-]+/g, '');
    
    setCurrentPage({
      ...currentPage,
      slug
    });
  };

  const handleReorderPages = async (result: { source: number; destination: number }) => {
    try {
      const reorderedPages = [...pages];
      const [movedPage] = reorderedPages.splice(result.source, 1);
      reorderedPages.splice(result.destination, 0, movedPage);
      
      setPages(reorderedPages);
      
      const pageIds = reorderedPages.map(page => page.id);
      
      for (let i = 0; i < pageIds.length; i++) {
        const { error } = await supabase
          .from('custom_pages')
          .update({ 
            last_modified: new Date().toISOString(),
            sort_order: i 
          })
          .eq('id', pageIds[i]);
        
        if (error) throw error;
      }
      
      toast({
        title: "Pages reordered",
        description: "The page order has been updated successfully."
      });
    } catch (error) {
      console.error('Error reordering pages:', error);
      await fetchPages();
      
      toast({
        title: "Error reordering pages",
        description: "There was a problem updating the page order. Please try again.",
        variant: "destructive"
      });
    }
  };

  return {
    pages,
    isLoading,
    isEditDialogOpen,
    currentPage,
    pageContent,
    handleCreatePage,
    handleEditPage,
    handleDeletePage,
    handleDuplicatePage,
    handleStatusToggle,
    handlePreviewPage,
    handleReorderPages,
    handleSavePage,
    handleTitleChange,
    handleSlugChange,
    setPageContent,
    setIsEditDialogOpen
  };
};
